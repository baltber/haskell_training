--Определите функцию, вычисляющую двойной факториал, то есть произведение натуральных чисел, не превосходящих заданного числа и имеющих ту же четность. Например: 7!!=7⋅5⋅3⋅17!!=7⋅5⋅3⋅1,  8!!=8⋅6⋅4⋅28!!=8⋅6⋅4⋅2. Предполагается, что аргумент функции может принимать только неотрицательные значения.

doubleFact :: Integer -> Integer
doubleFact 0 = 1
doubleFact n = if n < 2 then 1 else n * doubleFact (n - 2)

--Последовательность чисел Фибоначчи 0,1,1,2,3,5,8,13,21,…0,1,1,2,3,5,8,13,21,… легко определить рекурсивно, задав два первых терминирующих значения и определив любое последующее как сумму двух непосредственно предыдущих:

--F0=0F0=0 

--F1=1F1=1 

--Fn=Fn−1+Fn−2Fn=Fn−1+Fn−2 

--На Haskell данное определение задаётся следующей функцией:

--fibonacci 0 = 0
--fibonacci 1 = 1
--fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)

--Эта функция определена лишь для неотрицательных чисел. Однако, из данного выше определения можно вывести формулу для вычисления чисел Фибоначчи при отрицательных индексах, при этом последовательность будет следующей:

--F−1=1,F−2=−1,…,F−10=−55,…F−1=1,F−2=−1,…,F−10=−55,… 

--Измените определение функции fibonacci так, чтобы она была определена для всех целых чисел и порождала при отрицательных аргументах указанную последовательность.﻿

fibonacci :: Integer -> Integer
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci (-1) = 1
fibonacci n | n > 0 = fibonacci (n - 1) + fibonacci (n - 2)
            | n < 0 = (-1)^(-n+1) * fibonacci(-n)


--Реализация функции для вычисления числа Фибоначчи, основанная на прямом рекурсивном определении, крайне неэффективна - количество вызовов функции растет экспоненциально с ростом значения аргумента. GHCi позволяет отслеживать использование памяти и затраты времени на вычисление выражения, для этого следует выполнить команду :set +s:

--GHCi> :set +s
--GHCi> fibonacci 30
--832040
--(8.36 secs, 298293400 bytes)

--С помощью механизма аккумуляторов попробуйте написать более эффективную реализацию, имеющую линейную сложность (по числу рекурсивных вызовов). Как и в предыдущем задании, функция должна быть определена для всех целых чисел.


fibonacci :: Integer -> Integer

fibonacci n | n == 0 = 0
      | n == 1 = 1
      | n == (-1) = 1
      | n > 0 = help 0 1 n
      | n < 0 = (help 0 1 (abs n)) * (-1)^((-n)-1)

help :: Integer -> Integer -> Integer -> Integer
help n m i | i == 1 = m
	   | otherwise = help m (n + m) (i-1)
